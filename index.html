<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Riddle Object Hunter â€” LM Studio Vision</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"></script>
  <style>
    :root {
      --bg: #0f0f12;
      --surface: #18181c;
      --border: #2a2a30;
      --text: #e4e4e7;
      --muted: #71717a;
      --accent: #4f46e5;
      --success: #16a34a;
      --error: #dc2626;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: "SF Pro Text", -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      min-height: 100vh;
      padding: 1.5rem;
    }

    h1 {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0 0 1rem 0;
      color: var(--accent);
    }

    .layout {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      max-width: 1200px;
      margin: 0 auto;
    }

    .main-row {
      display: flex;
      gap: 1.5rem;
      align-items: stretch;
    }

    .main-row .riddle-section {
      flex: 0 0 280px;
    }

    .main-row .camera-section {
      flex: 1;
      min-width: 0;
    }

    .main-row .result-section {
      flex: 0 0 220px;
    }

    @media (max-width: 900px) {
      .main-row {
        flex-direction: column;
      }

      .main-row .riddle-section {
        flex: none;
      }
    }

    .camera-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }

    .camera-section h2 {
      font-size: 0.875rem;
      font-weight: 500;
      margin: 0;
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      color: var(--muted);
    }

    .video-wrap {
      position: relative;
      aspect-ratio: 4/3;
      max-height: 360px;
      background: #000;
    }

    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    #snapshot {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      pointer-events: none;
    }

    .status {
      padding: 0.75rem 1rem;
      border-top: 1px solid var(--border);
      font-size: 0.8125rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
      flex-shrink: 0;
    }

    .status-dot.live {
      background: var(--success);
      box-shadow: 0 0 8px var(--success);
    }

    .status-dot.error {
      background: var(--error);
    }

    .result-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem 1.25rem;
    }

    .result-section h2 {
      font-size: 0.875rem;
      font-weight: 500;
      margin: 0 0 0.5rem 0;
      color: var(--muted);
    }

    .result-display {
      font-size: 1.125rem;
      font-weight: 600;
    }

    .result-display .item {
      margin-bottom: 0.25rem;
    }

    .result-display .item.yes {
      color: var(--success);
    }

    .result-display .item.no {
      color: var(--muted);
    }

    .result-display.pending .item {
      color: var(--muted);
    }

    .result-display.error {
      color: var(--error);
    }

    .debug-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 0.5rem;
    }

    .debug-group h3 {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      margin-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
      padding-bottom: 0.25rem;
    }

    .next-capture {
      font-size: 0.8125rem;
      color: var(--muted);
      margin-top: 0.5rem;
    }

    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    button {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      cursor: pointer;
      font-family: inherit;
    }

    button:hover {
      background: var(--border);
      border-color: var(--accent);
      color: var(--accent);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #canvas {
      display: none;
    }

    .riddle-section {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem 1.25rem;
    }

    .riddle-section h2 {
      font-size: 0.875rem;
      font-weight: 500;
      margin: 0 0 0.5rem 0;
      color: var(--muted);
    }

    .riddle-category {
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.25rem;
      display: none;
    }

    .category-object {
      color: #fbbf24;
    }

    .category-occlusion {
      color: #8b5cf6;
    }

    .riddle-text {
      font-size: 1.125rem;
      font-style: italic;
      color: var(--text);
      margin-bottom: 0.5rem;
    }

    .riddle-feedback {
      font-size: 1rem;
      font-weight: 600;
      min-height: 1.5em;
    }

    .riddle-feedback.correct {
      color: var(--success);
    }

    .riddle-feedback.wrong {
      color: var(--muted);
    }

    .riddle-feedback.waiting {
      color: var(--muted);
      font-weight: 400;
      font-style: italic;
    }

    .spirit-section {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 0.75rem;
      padding: 2rem 1rem;
      min-height: 140px;
    }

    .spirit-progress {
      font-size: 0.875rem;
      color: var(--muted);
    }

    .spirit-blob {
      width: 120px;
      height: 120px;
      border-radius: 45% 55% 60% 40% / 55% 45% 55% 45%;
      background-color: #6b7280;
      transition: background-color 0.6s ease, box-shadow 0.6s ease, transform 0.4s ease;
      animation: blob-morph 8s ease-in-out infinite;
    }

    .spirit-blob.fully-awakened {
      animation: blob-enthusiastic 3s ease-in-out infinite, spirit-glow 1.5s ease-in-out infinite;
    }

    @keyframes blob-morph {

      0%,
      100% {
        border-radius: 45% 55% 60% 40% / 55% 45% 55% 45%;
        transform: scale(1);
      }

      25% {
        border-radius: 55% 45% 50% 50% / 45% 55% 45% 55%;
        transform: scale(1.02);
      }

      50% {
        border-radius: 50% 50% 45% 55% / 55% 50% 50% 45%;
        transform: scale(0.98);
      }

      75% {
        border-radius: 45% 55% 55% 45% / 50% 50% 55% 45%;
        transform: scale(1.01);
      }
    }

    @keyframes blob-enthusiastic {

      0%,
      100% {
        border-radius: 40% 60% 65% 35% / 60% 40% 60% 40%;
        transform: scale(1) translateY(0);
      }

      12.5% {
        border-radius: 65% 35% 40% 60% / 35% 65% 35% 65%;
        transform: scale(1.08) translateY(-6px);
      }

      25% {
        border-radius: 55% 45% 60% 40% / 50% 55% 45% 55%;
        transform: scale(0.95) translateY(2px);
      }

      37.5% {
        border-radius: 35% 65% 55% 45% / 65% 40% 60% 35%;
        transform: scale(1.06) translateY(-4px);
      }

      50% {
        border-radius: 60% 40% 35% 65% / 45% 60% 40% 55%;
        transform: scale(0.97) translateY(1px);
      }

      62.5% {
        border-radius: 45% 55% 65% 35% / 55% 45% 55% 45%;
        transform: scale(1.07) translateY(-5px);
      }

      75% {
        border-radius: 50% 50% 45% 55% / 60% 50% 50% 40%;
        transform: scale(0.96) translateY(3px);
      }

      87.5% {
        border-radius: 55% 45% 50% 50% / 40% 60% 40% 60%;
        transform: scale(1.05) translateY(-3px);
      }
    }

    .spirit-blob.spirit-wrong {
      animation: spirit-wrong-pulse 0.6s ease-out;
      background-color: #ef4444 !important;
    }

    .spirit-blob.spirit-correct {
      animation: spirit-correct-swirl 1.2s ease-in-out;
      background-color: #10b981 !important;
    }

    @keyframes spirit-wrong-pulse {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
      }

      50% {
        transform: scale(1.1);
        box-shadow: 0 0 30px 10px rgba(239, 68, 68, 0.6);
      }

      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
      }
    }

    @keyframes spirit-correct-swirl {
      0% {
        transform: scale(1) rotate(0deg);
        box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
      }

      40% {
        transform: scale(1.2) rotate(160deg);
        box-shadow: 0 0 40px 15px rgba(16, 185, 129, 0.7);
      }

      80% {
        transform: scale(1.1) rotate(340deg);
        box-shadow: 0 0 20px 5px rgba(16, 185, 129, 0.4);
      }

      100% {
        transform: scale(1) rotate(360deg);
        box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
      }
    }

    @keyframes spirit-glow {

      0%,
      100% {
        filter: brightness(1);
      }

      50% {
        filter: brightness(1.4);
      }
    }
  </style>
</head>

<body>
  <div class="layout">
    <h1>Riddle Object Hunter</h1>

    <div class="main-row">
      <section class="riddle-section">
        <div class="riddle-category" id="riddleCategory"></div>
        <h2>Your hint</h2>
        <div class="riddle-text" id="riddleText">Start the game to see your first riddle!</div>
        <div class="riddle-feedback waiting" id="riddleFeedback"></div>
        <div class="controls" style="margin-top: 1rem">
          <button type="button" id="btnStart">Start</button>
          <button type="button" id="btnStop" disabled>Stop</button>
        </div>
      </section>

      <section class="camera-section">
        <h2>Camera</h2>
        <div class="video-wrap">
          <video id="video" autoplay playsinline muted></video>
          <img id="snapshot" alt="Last snapshot" />
        </div>
        <div class="status" id="status">
          <span class="status-dot" id="statusDot"></span>
          <span id="statusText">Starting cameraâ€¦</span>
        </div>
      </section>

      <section class="result-section">
        <h2>Debug Dashboard</h2>
        <div class="result-display pending" id="resultDisplay">
          <div class="debug-grid">
            <div class="debug-group">
              <h3>Objects (Vision AI)</h3>
              <div class="item" id="penResult">Pen: â€”</div>
              <div class="item" id="travelMugResult">Travel Mug: â€”</div>
              <div class="item" id="mouseResult">Mouse: â€”</div>
              <div class="item" id="phoneResult">Phone: â€”</div>
              <div class="item" id="bottleResult">Bottle: â€”</div>
              <div class="item" id="glassesResult">Glasses: â€”</div>
              <div class="item" id="watchResult">Watch: â€”</div>
              <div class="item" id="headphonesResult">Headphones: â€”</div>
            </div>
            <div class="debug-group">
              <h3>Webcam Occlusion (Vision AI)</h3>
              <div class="item" id="topOccludedResult">Top half: â€”</div>
              <div class="item" id="bottomOccludedResult">Bottom half: â€”</div>
              <div class="item" id="rightOccludedResult">Right half: â€”</div>
              <div class="item" id="leftOccludedResult">Left half: â€”</div>
              <div class="item" id="fullOccludedResult">Full occlusion: â€”</div>
            </div>
          </div>
        </div>
        <div class="next-capture" id="nextCapture"></div>
      </section>
    </div>

    <section class="spirit-section">
      <div class="spirit-blob" id="spiritBlob"></div>
      <div class="spirit-progress" id="spiritProgress">0/3 objects</div>
    </section>
  </div>

  <canvas id="canvas"></canvas>

  <script>
    const LM_STUDIO_BASE = "http://localhost:1234";
    const MODEL = "qwen3-vl-4b";
    const INTERVAL_MS = 10_000;

    const RIDDLES = [
      // PEN
      { riddle: "I have a point but no edges. I help you write but I'm not a keyboard. What am I?", key: "hasPen" },
      { riddle: "I hold your ideas on paper, but I'm not a printer. What am I?", key: "hasPen" },
      { riddle: "I bleed ink to tell your story. What am I?", key: "hasPen" },
      { riddle: "I'm mightier than the sword and fits in your pocket. What am I?", key: "hasPen" },
      { riddle: "I am the scribe's best friend. What am I?", key: "hasPen" },
      // TRAVEL MUG
      { riddle: "I have no handle and I'm built for the road. I keep your coffee hot. What am I?", key: "hasTravelMug" },
      { riddle: "I'm a cylinder of warmth with a lid for a cap, perfect for a commute. What am I?", key: "hasTravelMug" },
      { riddle: "I hold your liquid fuel but have no ears to hold onto. What am I?", key: "hasTravelMug" },
      { riddle: "Indestructible and insulated, I am the traveler's companion for tea. What am I?", key: "hasTravelMug" },
      { riddle: "I am a mug that lost its handle but gained a lid for the journey. What am I?", key: "hasTravelMug" },
      // MOUSE
      { riddle: "I have a tail but I'm not an animal. I help you navigate the digital world. What am I?", key: "hasMouse" },
      { riddle: "I have buttons and a cord or wireless connection. I move the cursor on your screen. What am I?", key: "hasMouse" },
      { riddle: "I guide your hand across the digital world, though I never leave your desk. What am I?", key: "hasMouse" },
      { riddle: "I have an optical eye but I am blind. I glide on a pad. What am I?", key: "hasMouse" },
      { riddle: "I scavenge for icons and click on links, yet I never eat cheese. What am I?", key: "hasMouse" },
      // PHONE
      { riddle: "I fit in your palm, I ring and I text. I connect you to the world. What am I?", key: "hasPhone" },
      { riddle: "I have a screen you tap and scroll. You carry me everywhere. What am I?", key: "hasPhone" },
      { riddle: "I am a pocket-sized window to everything, yet I am easily lost. What am I?", key: "hasPhone" },
      { riddle: "I wake you up in the morning and glow in the dark at night. I am your smart companion. What am I?", key: "hasPhone" },
      { riddle: "I have no mouth but I speak for you, no ears but I hear the world. What am I?", key: "hasPhone" },
      // BOTTLE
      { riddle: "I store liquids with a twist-off cap. I keep you hydrated. What am I?", key: "hasBottle" },
      { riddle: "Water, soda, or juiceâ€”I hold them all. I'm usually plastic or glass. What am I?", key: "hasBottle" },
      { riddle: "I carry your thirst-quencher, often recycled but rarely empty. What am I?", key: "hasBottle" },
      { riddle: "I have a neck but no head, and I wear a crown made of plastic or metal. What am I?", key: "hasBottle" },
      { riddle: "I am a transparent cylinder that gurgles when you tilt me. What am I?", key: "hasBottle" },
      // GLASSES
      { riddle: "I have two eyes but cannot see, I sit on your nose and help you read. What am I?", key: "hasGlasses" },
      { riddle: "I have frames and lenses, shielding you from the sun or clarifying your view. What am I?", key: "hasGlasses" },
      { riddle: "I am worn on the face to sharpen the world or darken the day. What am I?", key: "hasGlasses" },
      { riddle: "I bridge your nose and cling to your ears to give you second sight. What am I?", key: "hasGlasses" },
      { riddle: "I am the windows you wear when the world gets blurry. What am I?", key: "hasGlasses" },
      // WATCH
      { riddle: "I have hands but no arms, a face but no eyes. I tell you the time from your wrist. What am I?", key: "hasWatch" },
      { riddle: "I tick and I tock, or I glow with digits, strapped securely to your arm. What am I?", key: "hasWatch" },
      { riddle: "I count the seconds and minutes while resting on your skin. What am I?", key: "hasWatch" },
      { riddle: "I am a steady heartbeat on your pulse, keeping you on schedule. What am I?", key: "hasWatch" },
      { riddle: "I have twelve numbers and two pointers, but I never do math. What am I?", key: "hasWatch" },
      // HEADPHONES
      { riddle: "I hug your ears and bring you music, but I don't speak a word. What am I?", key: "hasHeadphones" },
      { riddle: "I have two cups but no coffee, I bridge your head to sound. What am I?", key: "hasHeadphones" },
      { riddle: "I isolate the world and fill your head with rhythm. What am I?", key: "hasHeadphones" },
      { riddle: "I am the earmuffs that sing to you. What am I?", key: "hasHeadphones" },
      { riddle: "I have a headband but no hair, and I live for the beat. What am I?", key: "hasHeadphones" },
      // OCCLUSIONS
      // TOP
      { riddle: "Hide the sky of my view with your hand.", key: "isTopOccluded" },
      { riddle: "Cover the upper ceiling of my visual world.", key: "isTopOccluded" },
      { riddle: "I see the floor, but the top is gone. Make it so.", key: "isTopOccluded" },
      { riddle: "Shadow the crown of my vision.", key: "isTopOccluded" },
      { riddle: "Place an eclipse on the upper half of my eye.", key: "isTopOccluded" },
      // BOTTOM
      { riddle: "Cover the floor of my vision.", key: "isBottomOccluded" },
      { riddle: "Hide the lower half of what I see.", key: "isBottomOccluded" },
      { riddle: "Block the path where the desk should be.", key: "isBottomOccluded" },
      { riddle: "Let my view be top-heavy; hide the bottom.", key: "isBottomOccluded" },
      { riddle: "Place an eclipse on the lower half of my eye.", key: "isBottomOccluded" },
      // RIGHT
      { riddle: "Block the right side of the world for me.", key: "isRightOccluded" },
      { riddle: "Cover my right eye's path.", key: "isRightOccluded" },
      { riddle: "I want to see only what is on the left.", key: "isRightOccluded" },
      { riddle: "Shadow the eastern side of my frame.", key: "isRightOccluded" },
      { riddle: "Make the right side of my vision disappear.", key: "isRightOccluded" },
      // LEFT
      { riddle: "Block the left side of the world for me.", key: "isLeftOccluded" },
      { riddle: "Cover my left eye's path.", key: "isLeftOccluded" },
      { riddle: "I want to see only what is on the right.", key: "isLeftOccluded" },
      { riddle: "Shadow the western side of my frame.", key: "isLeftOccluded" },
      { riddle: "Make the left side of my vision disappear.", key: "isLeftOccluded" },
      // FULL
      { riddle: "Plunge me into total darkness.", key: "isFullOccluded" },
      { riddle: "Blind me completely with your hand.", key: "isFullOccluded" },
      { riddle: "I want to see nothing at all. Block my lens.", key: "isFullOccluded" },
      { riddle: "Total eclipse! Cover my entire eye.", key: "isFullOccluded" },
      { riddle: "Make the screen go black with a full cover.", key: "isFullOccluded" },
    ];

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    let sessionRiddles = [];

    const video = document.getElementById("video");
    const snapshotImg = document.getElementById("snapshot");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const statusDot = document.getElementById("statusDot");
    const statusText = document.getElementById("statusText");
    const resultDisplay = document.getElementById("resultDisplay");
    const ITEM_RESULTS = [
      { id: "penResult", key: "hasPen", label: "Pen" },
      { id: "travelMugResult", key: "hasTravelMug", label: "Travel Mug" },
      { id: "mouseResult", key: "hasMouse", label: "Mouse" },
      { id: "phoneResult", key: "hasPhone", label: "Phone" },
      { id: "bottleResult", key: "hasBottle", label: "Bottle" },
      { id: "glassesResult", key: "hasGlasses", label: "Glasses" },
      { id: "watchResult", key: "hasWatch", label: "Watch" },
      { id: "headphonesResult", key: "hasHeadphones", label: "Headphones" },
      { id: "topOccludedResult", key: "isTopOccluded", label: "Top half" },
      { id: "bottomOccludedResult", key: "isBottomOccluded", label: "Bottom half" },
      { id: "rightOccludedResult", key: "isRightOccluded", label: "Right half" },
      { id: "leftOccludedResult", key: "isLeftOccluded", label: "Left half" },
      { id: "fullOccludedResult", key: "isFullOccluded", label: "Full occlusion" },
    ].map((r) => ({ ...r, el: document.getElementById(r.id) }));
    const riddleCategory = document.getElementById("riddleCategory");
    const nextCapture = document.getElementById("nextCapture");
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const riddleText = document.getElementById("riddleText");
    const riddleFeedback = document.getElementById("riddleFeedback");
    const spiritBlob = document.getElementById("spiritBlob");
    const spiritProgress = document.getElementById("spiritProgress");

    const SPIRIT_COLORS = [
      "#6b7280",
      "#4a8a94",
      "#22b8c9",
      "#22d3ee",
    ];

    let stream = null;
    let intervalId = null;
    let nextCaptureAt = null;
    let nextCaptureTimerId = null;
    let currentRiddle = null;
    let correctCount = 0;

    function updateSpirit() {
      const step = Math.min(correctCount, 3);
      spiritBlob.style.backgroundColor = SPIRIT_COLORS[step];
      spiritBlob.style.boxShadow = step === 3
        ? `0 0 40px ${SPIRIT_COLORS[3]}, 0 0 80px ${SPIRIT_COLORS[3]}80`
        : "none";
      spiritBlob.classList.toggle("fully-awakened", step === 3);
      spiritProgress.textContent = step === 3 ? "Spirit awakened!" : `${step}/3 objects`;
    }

    function pickNewRiddle() {
      if (sessionRiddles.length === 0) {
        sessionRiddles = shuffleArray([...RIDDLES]);
      }
      currentRiddle = sessionRiddles.pop();
      riddleText.textContent = `"${currentRiddle.riddle}"`;

      const isOcclusion = currentRiddle.key.startsWith("is") && currentRiddle.key.includes("Occluded");

      riddleCategory.style.display = "block";
      riddleCategory.textContent = isOcclusion ? "Occlude the camera" : "Find the object";
      riddleCategory.className = `riddle-category ${isOcclusion ? 'category-occlusion' : 'category-object'}`;

      riddleFeedback.textContent = isOcclusion ? "Cover the camera as hinted!" : "Find and hold the object!";
      riddleFeedback.className = "riddle-feedback waiting";
    }

    function setRiddleFeedback(correct) {
      riddleFeedback.classList.remove("correct", "wrong", "waiting");
      spiritBlob.classList.remove("spirit-correct", "spirit-wrong");

      // Trigger reflow to restart animation
      void spiritBlob.offsetWidth;

      if (correct) {
        correctCount = Math.min(3, correctCount + 1);
        updateSpirit();
        spiritBlob.classList.add("spirit-correct");
        riddleFeedback.classList.add("correct");
        riddleFeedback.textContent = correctCount >= 3 ? "Spirit awakened! ðŸŽ‰" : "Correct! ðŸŽ‰";
        setTimeout(() => {
          spiritBlob.classList.remove("spirit-correct");
          pickNewRiddle();
        }, 1500);
      } else {
        // Progress is not lost anymore
        spiritBlob.classList.add("spirit-wrong");
        riddleFeedback.classList.add("wrong");
        riddleFeedback.textContent = "Not quiteâ€”try again!";
        setTimeout(() => {
          spiritBlob.classList.remove("spirit-wrong");
          riddleFeedback.classList.remove("wrong");
          riddleFeedback.classList.add("waiting");

          const isOcc = currentRiddle.key.startsWith("is") && currentRiddle.key.includes("Occluded");
          riddleFeedback.textContent = isOcc ? "Cover the camera as hinted!" : "Find and hold the object!";
        }, 2000);
      }
    }

    function setStatus(ok, text) {
      statusDot.classList.remove("live", "error");
      statusDot.classList.add(ok ? "live" : "error");
      statusText.textContent = text;
    }

    function setDetectionResult(value, isError = false) {
      resultDisplay.classList.remove("pending", "error");
      ITEM_RESULTS.forEach((r) => r.el.classList.remove("yes", "no"));
      if (isError) {
        resultDisplay.classList.add("error");
        ITEM_RESULTS[0].el.textContent = value;
        ITEM_RESULTS.slice(1).forEach((r) => (r.el.textContent = ""));
      } else if (value == null) {
        resultDisplay.classList.add("pending");
        ITEM_RESULTS.forEach((r) => (r.el.textContent = `${r.label}: â€”`));
      } else {
        ITEM_RESULTS.forEach((r) => {
          const v = value[r.key];
          const isOcclusion = r.key.startsWith("is") && r.key.includes("Occluded");

          let statusSuffix;
          if (v) {
            statusSuffix = isOcclusion ? "occluded âœ“" : "holding âœ“";
          } else {
            statusSuffix = isOcclusion ? "not occluded" : "not holding";
          }

          r.el.textContent = `${r.label}: ${statusSuffix}`;
          r.el.classList.add(v ? "yes" : "no");
        });
      }
    }

    function scheduleNextLabel() {
      if (nextCaptureTimerId) clearTimeout(nextCaptureTimerId);
      nextCaptureAt = Date.now() + INTERVAL_MS;
      const update = () => {
        const left = Math.max(
          0,
          Math.ceil((nextCaptureAt - Date.now()) / 1000)
        );
        nextCapture.textContent =
          left > 0 ? `Next snapshot in ${left}s` : "Capturingâ€¦";
        if (left > 0) nextCaptureTimerId = setTimeout(update, 500);
      };
      update();
    }

    function captureFrame() {
      if (!stream || video.readyState < 2) return null;
      const w = video.videoWidth;
      const h = video.videoHeight;
      const ctx = canvas.getContext("2d");
      canvas.width = w;
      canvas.height = h;
      ctx.drawImage(video, 0, 0);
      const dataUrl = canvas.toDataURL("image/jpeg", 0.7);

      const snapshotImg = document.getElementById("snapshot");
      if (snapshotImg) {
        snapshotImg.src = dataUrl;
        snapshotImg.style.opacity = "1";
        setTimeout(() => {
          snapshotImg.style.opacity = "0";
        }, 500);
      }
      return dataUrl;
    }

    async function askDetectItems(dataUrl) {
      const body = {
        model: MODEL,
        messages: [
          {
            role: "system",
            content:
              "You are a vision assistant. Look at the image and answer only with the requested JSON. No other text.",
          },
          {
            role: "user",
            content: [
              {
                type: "text",
                text:
                  "Is the person in this image holding an item or covering part of the camera? Reply with JSON: {\"hasPen\": bool, \"hasTravelMug\": bool, \"hasMouse\": bool, \"hasPhone\": bool, \"hasBottle\": bool, \"hasGlasses\": bool, \"hasWatch\": bool, \"hasHeadphones\": bool, \"isTopOccluded\": bool, \"isBottomOccluded\": bool, \"isRightOccluded\": bool, \"isLeftOccluded\": bool, \"isFullOccluded\": bool}. Items: pen, travel mug (insulated, handle-less, often metallic or plastic with a lid), mouse, phone, bottle, glasses, watch, headphones. Occlusions: isTopOccluded (upper half covered), isBottomOccluded (lower half covered), isRightOccluded (right half covered), isLeftOccluded (left half covered), isFullOccluded (entire lens covered).",
              },
              { type: "image_url", image_url: { url: dataUrl } },
            ],
          },
        ],
        response_format: {
          type: "json_schema",
          json_schema: {
            name: "item_response",
            strict: true,
            schema: {
              type: "object",
              properties: {
                hasPen: { type: "boolean" },
                hasTravelMug: { type: "boolean" },
                hasMouse: { type: "boolean" },
                hasPhone: { type: "boolean" },
                hasBottle: { type: "boolean" },
                hasGlasses: { type: "boolean" },
                hasWatch: { type: "boolean" },
                hasHeadphones: { type: "boolean" },
                isTopOccluded: { type: "boolean" },
                isBottomOccluded: { type: "boolean" },
                isRightOccluded: { type: "boolean" },
                isLeftOccluded: { type: "boolean" },
                isFullOccluded: { type: "boolean" },
              },
              required: ["hasPen", "hasTravelMug", "hasMouse", "hasPhone", "hasBottle", "hasGlasses", "hasWatch", "hasHeadphones", "isTopOccluded", "isBottomOccluded", "isRightOccluded", "isLeftOccluded", "isFullOccluded"],
            },
          },
        },
        temperature: 0,
        max_tokens: 400,
        stream: false,
      };

      const res = await fetch(`${LM_STUDIO_BASE}/v1/chat/completions`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        const errText = await res.text();
        throw new Error(
          `LM Studio ${res.status}: ${errText || res.statusText}`
        );
      }

      const data = await res.json();
      const content = data?.choices?.[0]?.message?.content;
      if (content == null) throw new Error("No content in response");

      const parsed = JSON.parse(content);
      const visionKeys = ["hasPen", "hasTravelMug", "hasMouse", "hasPhone", "hasBottle", "hasGlasses", "hasWatch", "hasHeadphones", "isTopOccluded", "isBottomOccluded", "isRightOccluded", "isLeftOccluded", "isFullOccluded"];
      for (const key of visionKeys) {
        if (typeof parsed[key] !== "boolean")
          throw new Error(`Invalid response: missing ${key} boolean`);
      }
      return {
        hasPen: parsed.hasPen,
        hasTravelMug: parsed.hasTravelMug,
        hasMouse: parsed.hasMouse,
        hasPhone: parsed.hasPhone,
        hasBottle: parsed.hasBottle,
        hasGlasses: parsed.hasGlasses,
        hasWatch: parsed.hasWatch,
        hasHeadphones: parsed.hasHeadphones,
        isTopOccluded: parsed.isTopOccluded,
        isBottomOccluded: parsed.isBottomOccluded,
        isRightOccluded: parsed.isRightOccluded,
        isLeftOccluded: parsed.isLeftOccluded,
        isFullOccluded: parsed.isFullOccluded,
      };
    }

    async function runCapture() {
      const dataUrl = captureFrame();
      if (!dataUrl) {
        setDetectionResult("No frame", true);
        scheduleNextLabel();
        return;
      }

      setDetectionResult(null);
      nextCapture.textContent = "Analyzingâ€¦";

      try {
        const finalResult = await askDetectItems(dataUrl);
        setDetectionResult(finalResult);

        if (currentRiddle && finalResult[currentRiddle.key]) {
          setRiddleFeedback(true);
        } else if (currentRiddle) {
          const anyHeld = ITEM_RESULTS.some((r) => finalResult[r.key]);
          if (anyHeld) setRiddleFeedback(false);
        }
      } catch (e) {
        console.error(e);
        setDetectionResult(e.message || "Request failed", true);
      }
      scheduleNextLabel();
    }

    function startInterval() {
      if (intervalId) return;
      correctCount = 0;
      sessionRiddles = []; // Reset session to force reshuffle
      updateSpirit();
      pickNewRiddle();
      runCapture();
      intervalId = setInterval(runCapture, INTERVAL_MS);
      btnStart.disabled = true;
      btnStop.disabled = false;
    }

    function stopInterval() {
      if (nextCaptureTimerId) {
        clearTimeout(nextCaptureTimerId);
        nextCaptureTimerId = null;
      }
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
      nextCapture.textContent = "";
      currentRiddle = null;
      riddleCategory.style.display = "none";
      riddleCategory.textContent = "";
      correctCount = 0;
      updateSpirit();
      riddleText.textContent = "Start the game to see your first riddle!";
      riddleFeedback.textContent = "";
      riddleFeedback.className = "riddle-feedback waiting";
      btnStart.disabled = false;
      btnStop.disabled = true;
    }

    async function initCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false,
        });
        video.srcObject = stream;
        await new Promise((resolve, reject) => {
          video.onloadedmetadata = resolve;
          video.onerror = () => reject(new Error("Video load failed"));
        });
        setStatus(true, "Camera live");
        btnStart.disabled = false;
      } catch (e) {
        setStatus(false, "Camera error: " + (e.message || "denied"));
        setDetectionResult("Camera failed", true);
      }
    }

    btnStart.addEventListener("click", startInterval);
    btnStop.addEventListener("click", stopInterval);

    initCamera();
  </script>
</body>

</html>